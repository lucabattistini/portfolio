#!/usr/bin/env node

import fs from 'node:fs/promises';
import path from 'node:path';
import url from 'node:url';
import glslify from 'glslify';

const __dirname = path.dirname(url.fileURLToPath(import.meta.url));
const repoRoot = path.resolve(__dirname, '..');

const VERT_PATH = path.join(repoRoot, 'src/components/particles/glsl/shader.vert');
const FRAG_PATH = path.join(repoRoot, 'src/components/particles/glsl/shader.frag');
const OUT_PATH = path.join(repoRoot, 'src/components/particles/generated-shaders.ts');

function toTemplateLiteral(glslSource) {
	// Keep the output stable (and avoid CRLF issues)
	const normalized = glslSource.replace(/\r\n/g, '\n');
	return '`' + normalized.replace(/`/g, '\\`') + '`';
}

async function main() {
	const [vertex, fragment] = await Promise.all([
		fs.readFile(VERT_PATH, 'utf8'),
		fs.readFile(FRAG_PATH, 'utf8'),
	]);

	const vertexOut = glslify(vertex, { basedir: path.dirname(VERT_PATH) });
	const fragmentOut = glslify(fragment, { basedir: path.dirname(FRAG_PATH) });

	const out = `// This file is generated by scripts/build-shaders.mjs. Do not edit by hand.\n\n` +
		`export function particlesVertexShader() {\n\treturn ${toTemplateLiteral(vertexOut)};\n}\n\n` +
		`export function particlesFragmentShader() {\n\treturn ${toTemplateLiteral(fragmentOut)};\n}\n`;

	await fs.writeFile(OUT_PATH, out, 'utf8');
}

main().catch((err) => {
	console.error(err);
	process.exit(1);
});
